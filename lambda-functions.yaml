AWSTemplateFormatVersion: '2010-09-09'
Description: 'Lambda Functions for Pet Image Labeling System'

Parameters:
  S3StorageStackName:
    Type: String
    Description: Name of the S3 storage CloudFormation stack
    Default: pet-image-labeling-storage
  
  DynamoDBStackName:
    Type: String
    Description: Name of the DynamoDB CloudFormation stack
    Default: pet-image-labeling-database

  AuthStackName:
    Type: String
    Description: Name of the Cognito authentication CloudFormation stack
    Default: pet-image-labeling-auth

  LambdaCodeBucket:
    Type: String
    Description: S3 bucket containing Lambda function code packages
    Default: pet-image-labeling-lambda-packages

Resources:
  # Token Validator Lambda Layer
  TokenValidatorLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !Sub "${AWS::StackName}-TokenValidator"
      Description: Common functions for validating Cognito tokens
      Content:
        S3Bucket: !Ref LambdaCodeBucket
        S3Key: token-validator-layer.zip
      CompatibleRuntimes:
        - nodejs18.x

  # Auth validator helper for API Gateway
  TokenValidatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-TokenValidator"
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Runtime: nodejs18.x
      Timeout: 10
      MemorySize: 128
      Environment:
        Variables:
          USER_POOL_ID: !ImportValue 
            !Sub "${AuthStackName}-UserPoolId"
      Code:
        ZipFile: |
          const jwt = require('jsonwebtoken');
          const jwksClient = require('jwks-rsa');

          // Cache for previously fetched public keys
          const keyCache = {};

          exports.handler = async (event) => {
            try {
              // Extract token from the Authorization header
              const token = event.authorizationToken;
              if (!token) {
                return generatePolicy('user', 'Deny', event.methodArn);
              }

              // Verify the token is a Bearer token
              const match = token.match(/^Bearer (.*)$/);
              if (!match || match.length < 2) {
                return generatePolicy('user', 'Deny', event.methodArn);
              }

              const idToken = match[1];
              
              // Get the kid (key ID) from the token header
              const tokenSections = idToken.split('.');
              if (tokenSections.length < 2) {
                throw new Error('Invalid token format');
              }
              
              const headerJSON = Buffer.from(tokenSections[0], 'base64').toString('utf8');
              const header = JSON.parse(headerJSON);
              const kid = header.kid;
              
              // Get the public key for verification
              const userPoolId = process.env.USER_POOL_ID;
              const jwksUri = `https://cognito-idp.${process.env.AWS_REGION}.amazonaws.com/${userPoolId}/.well-known/jwks.json`;
              
              // Check if we already have the key in the cache
              let pem;
              if (keyCache[kid]) {
                pem = keyCache[kid];
              } else {
                // Fetch the public key
                const client = jwksClient({
                  jwksUri: jwksUri
                });
                
                const key = await new Promise((resolve, reject) => {
                  client.getSigningKey(kid, (err, result) => {
                    if (err) {
                      reject(err);
                    } else {
                      resolve(result);
                    }
                  });
                });
                
                pem = key.publicKey || key.rsaPublicKey;
                
                // Cache the key
                keyCache[kid] = pem;
              }
              
              // Verify the token
              const decodedToken = await new Promise((resolve, reject) => {
                jwt.verify(idToken, pem, { algorithms: ['RS256'] }, (err, decoded) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(decoded);
                  }
                });
              });
              
              // Check if token is expired
              const currentTimestamp = Math.floor(Date.now() / 1000);
              if (decodedToken.exp <= currentTimestamp) {
                throw new Error('Token expired');
              }
              
              // Extract user information from the token
              const user = {
                sub: decodedToken.sub,
                email: decodedToken.email,
                name: decodedToken.name,
                groups: decodedToken['cognito:groups'] || []
              };
              
              // Generate the policy
              return generatePolicy(user.sub, 'Allow', event.methodArn, user);
              
            } catch (error) {
              console.error('Token validation error:', error);
              return generatePolicy('user', 'Deny', event.methodArn);
            }
          };

          // Helper function to generate an IAM policy
          function generatePolicy(principalId, effect, resource, context) {
            const authResponse = {
              principalId: principalId
            };
            
            if (effect && resource) {
              const policyDocument = {
                Version: '2012-10-17',
                Statement: [{
                  Action: 'execute-api:Invoke',
                  Effect: effect,
                  Resource: resource
                }]
              };
              authResponse.policyDocument = policyDocument;
            }
            
            // Add user context for lambda functions
            if (context) {
              authResponse.context = context;
            }
            
            return authResponse;
          }

  # 1. Image Upload Handler Lambda Function
  ImageUploadFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-ImageUpload"
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Runtime: nodejs18.x
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          RAW_BUCKET: !Sub "${S3StorageStackName}-pet-images-raw"
          PROCESSED_BUCKET: !Sub "${S3StorageStackName}-pet-images-processed"
          IMAGES_TABLE: !Sub "${DynamoDBStackName}-Images"
      Code:
        S3Bucket: !Ref LambdaCodeBucket
        S3Key: "image-processor.zip"

  # S3 event notification for image uploads
  ImageUploadEventPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ImageUploadFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub "arn:aws:s3:::${S3StorageStackName}-pet-images-raw"

  # 2. Get Images API Handler Lambda Function
  GetImagesFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-GetImages"
      Handler: index.handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LabRole"
      Runtime: nodejs18.x
      Timeout: 10
      MemorySize: 256
      Environment:
        Variables:
          PROCESSED_BUCKET: !Sub "${S3StorageStackName}-pet-images-processed"
          IMAGES_TABLE: !Sub "${DynamoDBStackName}-Images"
      Code:
        ZipFile: |
          const { S3Client } = require("@aws-sdk/client-s3");
          const { getSignedUrl } = require("@aws-sdk/s3-request-presigner");
          const { GetObjectCommand } = require("@aws-sdk/client-s3");
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, QueryCommand } = require("@aws-sdk/lib-dynamodb");

          exports.handler = async (event) => {
            try {
              // Create clients
              const s3Client = new S3Client({ region: process.env.AWS_REGION });
              const ddbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
              const docClient = DynamoDBDocumentClient.from(ddbClient);
              
              // Extract user info from context if available
              const currentUser = event.requestContext?.authorizer?.lambda;
              console.log('Current user:', currentUser);
              
              // Parse query parameters
              const queryParams = event.queryStringParameters || {};
              const labelStatus = queryParams.status || 'unlabeled';
              const limit = parseInt(queryParams.limit) || 10;
              
              // Query DynamoDB for images with the specified label status
              const queryCommand = new QueryCommand({
                TableName: process.env.IMAGES_TABLE,
                IndexName: 'LabelStatusIndex',
                KeyConditionExpression: 'labelStatus = :status',
                ExpressionAttributeValues: {
                  ':status': labelStatus
                },
                Limit: limit
              });
              
              const result = await docClient.send(queryCommand);
              
              // Generate presigned URLs for each image
              const imagesWithUrls = await Promise.all(result.Items.map(async (image) => {
                const command = new GetObjectCommand({
                  Bucket: process.env.PROCESSED_BUCKET,
                  Key: image.thumbnailKey
                });
                
                const thumbnailUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
                
                return {
                  ...image,
                  thumbnailUrl
                };
              }));
              
              return {
                statusCode: 200,
                headers: {
                  'Access-Control-Allow-Origin': '*', // Adjust for production
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(imagesWithUrls)
              };
            } catch (error) {
              console.error('Error getting images:', error);
              return {
                statusCode: 500,
                headers: {
                  'Access-Control-Allow-Origin': '*', // Adjust for production
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ message: 'Error retrieving images', error: error.message })
              };
            }
          };